# DDD 戰術設計：Aggregate 聚合設計 (續)

## Aggregate 設計原則

### 一至性邊界

舉個例子，有一個固定規則是 `c = a + b`。因此若 `a` 為 2、`b` 為 3，那 `c` 就一定要是 5，否則就會破壞這個規則。

1. Aggregate 邊界 = Transaction 邊界
2.

讓我們來看看如何達成：

### 設計小 Aggregate

性能與擴展性。

盡量減少 Entity，這會讓你追蹤他的變化週期更加複雜，而且也會讓你在操作資料庫時，需要多做 JOIN。如果你的這個物件可以被整個替換掉，那就可以考慮建成 Value Object。請記得，Entity 與 Value Object 都是相對的概念，沒有一定的標準。

### 使用唯一標示引用其他 Aggregate Root

如果你想要在一個 Transaction 內修改多個 Aggregate，那可能代表你的一致性邊界出錯了。如果你覺得 Aggregate 太大不利於效能而需要拆分他，導致一個使用案例需要修改到多個 Aggregate，這時你可以考慮「最終一致性」的方案。

好處是，你不需要直接引用對方整個物件，只需要一個 ID，這樣代表你的效能也會更好，佔用更少的內存。

### 最終一致性

> 任何跨聚合的業務規則都不能總是保持最新的狀態。通過事件處理、批處理或者其他更新機制，我們可以在**一定時間**之內處理好他方依賴。

在這時候你也可以更加了解你的領域，要知道，其實用戶並不在乎你是使用哪種一致性，0.1 秒的延遲跟 0.3 秒的延遲對用戶來說是可以忍受的。

舉一個最簡單的例子：

## Aggregate 間的交流

## 打破原則

## 持久化

一個 Repository 最好對應一個 Aggregate，我們才能保證這次的改變能符合一致性邊界。

## Reference
